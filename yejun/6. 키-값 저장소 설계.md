# 6장. 키-값 저장소 설계
## *키-값 저장소 (key-value store) 란?*

키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스

→ 이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 함

> 키와 값 사이의 연결 관계 = **“키-값” 쌍(pair)**
> 
- `put(key, value)` : 키-값 쌍을 저장소에 저장
- `get(key)` : 인자로 주어진 키에 매달린 값을 꺼냄

[대표적 예시] 

Amazon DynamoDB, memcached, Redis 

# 키-값 저장소를 설계해보자!

<aside>
💡 **문제 이해 및 설게 범위**

- 키-값 쌍의 크기는 10KB 이하이다.
- 큰 데이터를 저장할 수 있어야 한다.
- 높은 가용성을 제공해야 한다 ⇒ 시스템이 장애가 있더라도 빨리 응답해야 한다
- 높은 규모 확장성을 제공해야 한다 ⇒ 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.
- 데이터 일관성 수준은 조정이 가능해야 한다
- 응답 지연시간(latency)이 짧아야 한다
</aside>

## 단일 서버 키-값 저장소

가장 직관적인 방식으로, 키-값 쌍 전부를 메모리에 해시 테이블로 저장

👍🏻 빠른 속도

👎🏻 모든 데이터를 수용하지 못할 수 있음

**⇒ 해결 방안**

- 데이터 압축
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

## 분산 키-값 저장소

분산 해시 테이블이라고도 불리며, 키-값 쌍을 여러 서버에 분산시키는 것

<aside>
💡 기본 배경 지식

### **CAP 정리**

- **Consistency, 일관성**
    
    분산 시스템에 접속하는 모든 클라이언트가 어떤 노드에 접속하든 항상 같은 데이터를 볼 수 있도록
    
- **Availability, 가용성**
    
    분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있도록
    
- **Partition Tolerance theorem, 파티션 감내**
    
    네트워크에 파티션이 생기더라도 시스템은 계속 동작하도록
    
    - 파티션 = 두 노드 사이에 통신 장애가 발생했음을 의미
    

위 세 가지 중 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다.

CP 시스템 : 일관성과 파티션 감내를 지원하는 키-값 저장소 → 가용성 희생

AP 시스템 : 가용성과 파티션 감내를 지원하는 키-값 저장소 → 데이터 일관성 희생

CA 시스템 : 일관성과 가용성을 지원하는 키-값 저장소 → 파티션 감내 희생  ***실제로는 존재X**

*요구사항에 맞도록 CAP 정리를 적용하며 시스템을 설계해야 한다.

</aside>

분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관되며, 이상적 환경이라면 네트워크가 파티션되는 상황은 절대 발생하지 않고 자동적으로 3대의 데이터가 동기화될 것이다.

하지만, 실세계에서는 네크워크 장애를 피할 수 없어 파티션 문제가 발생할 수 있고, 우리는 이때 일관성과 가용성 사이에서 하나를 선택해야 한다. 그렇다면 3대 간의 통신이 끊기게 되고, 옛날 기록으로 남아있는 등 데이터의 정합성이 깨지게 될 것이다. 

**n3에 장애가 발생한 경우*

1. **일관성** 선택 시
    
    3개 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 n1과 n2에 대한 쓰기 연산을 중단시켜야 한다. 
    
    → 가용성에 문제 발생 🚨
    
2. **가용성** 선택 시
    
    낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야 한다.
    
    → n1과 n2는 계속 쓰기 연산을 허용할 것이고, 파티션 문제가 해결된 뒤에 새 데이터를 n3에 전송!
    

### 시스템 컴포넌트

- 데이터 파티션
- 데이터 다중화(replication)
- 일관성(consistency)
- 일관성 불일치 해소(inconsistency resolution)
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로(write path)
- 읽기 경로(read path)

### 데이터를 파티션 단위로 나누자

*하나의 서버에 전체 데이터를 욱여넣을 수는 없으므로!

[고려 사항]

1. 데이터를 여러 서버에 고르게 분산할 수 있는가
2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화 할 수 있는가

[적합한 기술]

- 안정 해시 : 해시 링 이용
    
    → 이를 풀기에 **안정 해시**가 적합한 기술이다!
    
- 규모 확장 자동화 : 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제
- 다양성 : 각 서버의 용량에 맞게 가상 노드의 수 조정 가능
    
    → 고성능 서버는 더 많은 가상 노드를 갖도록 설정할 수 있다
    

### 데이터를 N개 서버에 비동기적으로 다중화하자

*N : 튜닝 가능한 값

[N개 서버를 선정하는 방법]

어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관하는 것

ex. N=3으로 설정할 때, key0은 s1, s2, s3에 저장

[주의 사항]

- 가상 노드를 사용하면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다
    
    ⇒ 노드 선택 시, 같은 물리 서버를 중복 선택하지 않도록 해야 함
    
- 같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연재해 등의 문제를 동시에 겪을 가능성이 있다
    
    ⇒ 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결된다
    

### 여러 노드에 다중화된 데이터는 적절히 동기화 되어야 한다

정족수 하의(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다

<aside>
📌 관계된 정의

- `N` = 사본 개수
- `W` = 쓰기 연산에 대한 정족수 → 쓰기 연산이 성공한 것으로 간주되려면, 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다
- `R` = 읽기 연산에 대한 정족수 → 읽기 연산이 성공한 것으로 간주되려면, 적어도 R개의 서버로부터 응답을 받아야 한다
</aside>

**[W = 1] : 쓰기 연산이 성공했다고 판단하기 위해 중재자는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야 한다**

→ 데이터가 한 대 서버에만 기록된다 (X)

성공 응답을 하나라도 받으면, 다른 서버의 응답은 기다릴 필요가 없다.

**⭐ 중재자 = 클라이언트-노드 사이의 Proxy 역할**

<aside>
💡 W, R, N의 값 정하기

> 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형적인 과정
> 
- W=1 or R=1
    
    중재자는 한 대 서버로부터의 응답만 받으면 되므로 응답속도는 빠르다
    
    - W=1, R=N : **빠른 쓰기 연산에 최적화된 시스템**
    - R=1, W=N : **빠른 읽기 연산에 최적화된 시스템**
- W>1 or R>1
    
    시스템이 보여주는 데이터 일관성의 수준은 향상될 테지만 중재자의 응답 속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려질 것이다
    
- W+R > N  (보통 N=3, W=R=2)
    
    **강한 일관성이 보장된다** → 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹칠 것이기 때문
    
- W+R ≤ N : **강한 일관성이 보장되지 않는다**
</aside>
*요구되는 일관성 수준에 따라 W,R,N의 값을 조정하면 된다.

### 데이터의 일관성 수준을 결정하는 일관성 모델을 고려하라

[종류]

- **강한 일관성**
    
    모든 읽기 연산은 가장 최근에 갱신된 결과를 반환 ⇒ 클라이언트가 절대로 낡은(out-of-date) 데이터를 보지 못한다
    
    → 이를 위해서는.. 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지해야 한다
    
- **약한 일관성**
    
    읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다
    
- **최종(eventual) 일관성**
    
    약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(즉, 동기화)되는 모델
    
    → 쓰기 연산이 병렬적으로 발생할 때, 시스템에 저장된 값들의 일관성이 깨질 수 있는데, 이는  클라이언트가 해결해야 한다
    

### 비 일관성 해소 기법 : 데이터 버저닝

데이터의 다중화는 가용성을 보장할 수 있지만, 사본 간의 일관성이 깨질 가능성이 높아진다. 

→ 이를 해결하기 위한 2가지 방법

1. **버저닝(versioning)**
    
    데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것을 의미
    
    *각 버전의 데이터는 변경 불가능(immutable)함
    
2. **벡터 시계(vector clock)**
    
    변경 전후의 버전 간 충돌이 발생할 때 자동적으로 해결할 수 있는 기술로, [서버, 버전]의 순서쌍을 데이터에 매달아 어떤 버전이 선행/후행 or 다른 버전과 충돌이 있는지 판별할 수 있다
    
    <aside>
    💡 표현 : <b>D([S1, v1], [S2, v2], …, [Sn, vn])</b>
    
    - D : 데이터
    - vi : 버전 카운터
    - Si : 서버 번호
    
    데이터 D를 서버 Si에 기록한다면, 시스템은 아래 작업 중 하나를 수행해야 한다
    
    1. [Si, vi]가 있으면 vi를 증가시킨다
    2. 그렇지 않으면 새 항목 [Si, 1]을 만든다
    </aside>
    
    → 위 추상적 로직을 구체적인 사례로 살펴보자!

