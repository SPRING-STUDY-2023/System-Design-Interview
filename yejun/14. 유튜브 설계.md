# 14장. 유튜브 설계 

<aside>
📊 YouTube의 통계 자료

- MAU : 20억 (2billion)
- 매일 재생되는 비디오 수 : 50억
- 이용자 수 : 미국 성인 중 73%가 이용
- 창작자 : 5천만 명
- 광고 수입 : 150억 달러(2019년 기준)  *2018년 보다 36% 증가
- 점유율 : 모바일 인터넷 트래픽 중 37%를 점유
- 다국어 지원 : 80개 언어로 이용 가능
</aside>

## 1단계  문제 이해 및 설계 범위 확정

유튜브는 비디오 시청 외에 댓글, 좋아요, 비디오 공유, 재생목록 저장, 채널 구독 기능 등 다양한 기능을 지원한다. 따라서 이 많은 기능 중 어느 범위까지 다뤄야 할지에 대해 설계 범위를 좁히는 과정이 필요하다. 

- `주요 기능`
    
    비디오 업로드 기능, 시청 기능
    
- `클라이언트 지원`
    
    모바일 앱, 웹 브라우저, 스마트 TV
    
- `DAU(일간 능동 사용자 수)`
    
    5백 만 명
    
- `평균 소비 시간`
    
    30분
    
- `다국어 지원`
    
    O
    

- `비디오 해상도 지원`
    
    현존하는 비디오 종류, 해상도 대부분
    
- `암호화`
    
    O
    
- `비디오 파일 최대 크기`
    
    작은 비디오, 중간 크기 비디오에 초점 → 최대 1GB로 제한
    
- `클라우드 서비스 이용`
    
    아마존, 구글, 마이크로소프트 등의 클라우드 서비스를 활용하는 것이 가능! (처음부터 쌓아올리는 것보다 바람직)
    

### 주요 기능 정리

1. 빠른 비디오 업로드
2. 원활한 비디오 재생
3. 재생 품질 선택 기능
4. 낮은 인프라 비용
5. 높은 가용성과 규모 확장성, 안정성
6. 지원 클라이언트 : 모바일 앱, 웹 브라우저, 스마트 TV

### 개략적 규모 추정

- DAU : 5백 만
- 한 사용자는 하루에 평균 5개의 비디오를 시청
- 10%의 사용자가 하루에 1개 비디오 업로드
- 비디오 평균 크기 : 300MB
- 비디오 저장을 위해 매일 새로 요구되는 저장 용량 : 5백만 X 10% X 300MB = 150TB
- CDN 비용
    - 클라우드 CDN을 통해 비디오를 서비스할 경우, CDN에서 나가는 데이터의 양에 따라 과금
    - 아마존의 CloudFront를 CDN 솔루션으로 사용할 경우,
        
        100% 트래픽이 미국에서 발생한다고 가정하면 → 1GB 당 $0.02의 요금이 발생  *비디오 스트리밍 비용만 따질 것
        
    
    ⇒ 매일 발생하는 요금 : 5백만 X 5비디오 X 0.3GB X $0.02 = $150,000
    

즉, CDN을 통해 비디오를 서비스하면 비용이 만만치 않다.

*이 비용을 줄이기 위해 상세 설계를 고려해보자!*

## 2단계  개략적 설계안 제시 및 동의 구하기

<aside>
🍯 꿀팁

- 시스템 설계 면접은 처음 밑바닥부터 만드는 것보다는 **주어진 시간 안에 적절한 기술을 골라 설계를 마치는 것**에 초점을 맞춰야 한다.
- 또한, 기술 각각이 어떻게 구현할지, 동작하는지 상세히 설명하는 것보다 중요하다. **해당 기술을 쓸 거라는 사실**만 언급해도 충분한 것이다.
</aside>

해당 설계에서는 CDN과 BLOB 스토리지에서 기존 클라우드 서비스를 활용하고자 한다. 

비디오를 저장하기 위한 BLOB 저장소나 CDN을 만드는 것은 복잡할 뿐만 아니라 많은 비용이 드는 일이다. 넷플릭스는 Amazon의 클라우드 서비스, 페이스북은 Akamai의 CDN을 활용하며, 그들도 스스로 구축하지 않는다.

![유튜브 시스템의 3가지 주요 컴포넌트](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/ec244aa7-bf5e-41c3-a679-a0d65aacf6b3)

유튜브 시스템의 3가지 주요 컴포넌트

- `단말(client)` : 컴퓨터, 모바일 폰, 스마트 TV를 통해서 유튜브를 시청할 수 있다
- `CDN` : 비디오를 저장하며, 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다
- `API 서버` : 비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리 → 피드 추천, 비디오 업로드 URL 생성, 메타데이터 DB와 캐시 갱신, 사용자 가입 등의 작업을 처리

> 설계 대상 : 비디오 업로드 절차, 비디오 스트리밍 절차
> 

### 비디오 업로드 절차

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/b4759e38-2cfc-4b19-86f1-b065a0b28b72)

- `사용자` : 컴퓨터나 모바일 폰, 스마트 TV를 통해 유튜브를 시청하는 이용자
- `로드밸런서` : API 서버 각각으로 고르게 요청을 분산하는 역할을 담당
- `API 서버` : 비디오 스트리밍을 제외한 다른 모든 요청을 처리
- `메타데이터 DB` : 비디오의 메타데이터를 보관 → 샤딩과 다중화를 적용하여 성능 및 가용성 요구사항을 충족
- `메타데이터 캐시` : 성능을 높이기 위해 비디오 메타데이터와 사용자 객체는 캐시
- `원본 저장소` : 원본 비디오를 보관할 대형 이진 파일 저장소 시스템
    - **BLOB, Binary Large Object storage** : 이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템
- `트랜스코딩 서버` : 비디오의 포맷(MPEG, HLS 등)을 변환하는 절차
    - 단말이나 대역폭 요구사항에 맞는 퇴적의 비디오 스트림을 제공하기 위해 필요함
    - 비디오 트랜스코딩 = 비디오 인코딩
- `트랜스코딩 비디오 저장소` : 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소
- `CDN` : 비디오를 캐시하는 역할 담당 → 사용자가 재생 버튼을 누르면 비디오 스트리밍이 CDN을 통해 이루어짐
- `트랜스코딩 완료 큐` : 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐
- `트랜스코딩 완료 핸들러` : 비디오 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 DB를 갱신할 작업 서버

> 아래 두 개 프로세스가 병렬적으로 처리된다ㅏ
> 
1. 비디오 업로드
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/570d57f6-613d-4a2a-9b7e-43b624e87caa)
    
    1. 비디오를 원본 저장소에 업로드
    2. 트랜스코딩 서버는 원본 저장소에서 해당 비디오를 가져와 트랜스코딩 시작
    3. 트랜스코딩이 완료되면 아래 두 절차가 병렬적으로 수행
        
        3a. 완료된 비디오를 트랜스코딩 비디오 저장소로 업로드
        
        3b. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣음
        
        → 완료 핸들러가 메타데이터 DB와 캐시를 갱신함
        
    4. API 서버가 단말에게 비디오 업로드가 끝나고, 스트리밍 준비가 되었음을 알림
    
2. 비디오 메타데이터 갱신
    
    **메타데이터 - 비디오 URL, 크기, 해상도, 포맷, 사용자 정보가 포함됨*
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/d4505d49-7acc-41d4-ae15-a13dcda259cd)
    
    1. 원본 저장소에 파일이 업로드되는 동안, 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보냄
    2. API 서버는 이 정보로 메타데이터 캐시와 DB를 업데이트

### 비디오 스트리밍 절차

<aside>
📌 스트리밍 프로토콜(streaming protocol)

> 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신방법
> 

[대표 예시]

- MPEG-DASH (Moving Picture Experts Group, Dynamic Adaptive Streaming over HTTP)
- 애플 HLS (HTTP Live Streaming)
- 마이크로소프트 Smooth 스트리밍
- 어도비 HTTP 동적 스트리밍(HDS)
</aside>

프로토콜은 구현의 디테일에 해당하므로 자세한 부분까지는 다루지 않겠다. 

프로토콜마다 지원하는 비디오 인코딩이 다르고, 플레이어 또한 다르다. 따라서, 비디오 스트리밍 서비스 설계 시에 서비스의 용례에 맞는 프로토콜을 잘 골라야 한다. 

- 비디오는 CDN에서 바로 스트리밍된다.
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/73efc225-3824-40c2-9cc4-ff396f4ffb50)
    
    사용자의 단말에 가장 가까운 CDN에서 서버(edge server)가 비디오 전송을 담당할 것이며, 전송지연은 아주 낮다. 
    

## 3단계  상세 설계

위에서 다룬 두 부분(비디오 업로드 절차, 비디오 스트리밍 절차)의 최적화 방안, 오류 처리 메커니즘을 더 상세히 다듬어보자. 

### 비디오 트랜스코딩

비디오를 녹화하면 단말(전화, 카메라 등)이 특정 포맷으로 비디오를 저장한다. 

어느 단말에서든 재생되도록 하려면, 다른 단말과 호환되는 비트레이트(bitrate)로 저장되어야 한다!

**비트레이트란? 비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위*

→ 비트레이트가 높을수록 고화질 비디오  (이를 정상 재생하려면 그만큼 높은 성능의 컴퓨팅 파워, 빠른 인터넷 회선 속도가 필요함)

<aside>
🎬 비디오 트랜스코딩이 왜 중요할까?

- 가공되지 않은 원본 비디오는 저장 공간을 많이 차지함
    
    ex. 초당 60프레임으로 녹화된 HD 비디오 - 수백 GB의 저장공간 차지
    
- 호환성 문제 : 상당수의 단말과 브라우저가 특정 종류의 비디오 포맷만 지원
    
    → 하나의 비디오를 여러 포맷으로 인코딩할 필요성 有
    
- 끊김 없는 비디오 제공 : 네트워크 대역폭이 충분하지 않다면, 저화질 비디오 / 충분하다면, 고화질 비디오를 상황에 따라 제공할 수 있음
- IN 네트워크 상황이 수시로 달라지는 모바일 환경 - 비디오 화질을 자동 또는 수동으로 변경할 수 있도록 지원
</aside>

인코딩 포맷은 매우 다양하며, 크게 아래 2가지 종류로 구분할 수 있다.

1. `컨테이너` : 비디오 파일, 오디오, 메타데이터를 담는 바구니와 같은 역할
    
    > .avi, .mov, .mp4
    > 
2. `코덱` : 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘
    
    > H.264, VP9, HEVC
    > 

### 유향 비순환 그래프(DAG) 모델

각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하면서, 처리 과정의 병렬성을 높이기 위해서는 적절한 수준의 추상화를 도입하여 클라이언트 프로그래머가 실행할 작업을 손수 정의할 수 있도록 해야 한다. 

- 비디오 트랜스코딩의 다양한 Case
    - 콘텐츠 창작자마다 요구사항 ≠
    - 비디오 위에 워터마크 표시
    - 썸네일 이미지 수작업
    - 희망하는 화질의 다양성

[EX] 페이스북의 스트리밍 비디오 엔진

DAG(Directed Acyclic Graph) 프로그래밍 모델을 도입하여, 작업을 단계별로 배열할 수 있도록 함

⇒ 해당 작업들은 순차적 or 병렬적으로 실행 가능

> DAG 모델을 도입하여 유연성과 병렬성을 달성할 수 있도록 하자!
> 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a5fb1b43-cb36-48a2-a243-a0b802acd3be)

원본 비디오는 비디오 / 오디오 / 메타데이터 세 부분으로 나뉘어 처리된다.

- **비디오 작업**
    - `검사`(inspection) : 좋은 품질의 비디오인가 ,손상이 없는가
    - `비디오 인코딩`(video encoding) : 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업
        
        ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/1585b8c8-4d45-4c7b-af37-f96f8cb38a74)
        
    - `썸네일`(thumbnail) : 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 썸네일을 만드는 작업
    - `워커마크`(watermark) : 비디오에 대한 식별정보를 이미지 위에 오버레이(overlay) 형태로 띄워 표시하는 작업
    

<aside>
📌 비디오 트랜스코딩 아키텍처

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/de3df187-41cb-4925-82a2-5fb5cf40cbdf)

### 전처리기(preprocessor)

[역할]

1. 비디오 분할 : 비디오 스트림을 GOP(Group of Pictures) 단위로 쪼갬
    
    → 특정 순서로 배열된 frame 그룹으로, 하나의 GOP는 독립적으로 재생 가능하며 길이는 보통 몇 초 정도이다. 
    
    **오래된 단말/브라우저는 GOP 단위의 분할을 지원하지 않아, 전처리기가 비디오 분할을 대신한다.*
    
2. DAG 생성 : 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만들어냄
3. 데이터 캐시 : GOP와 메타데이터를 임시 저장소에 보관해두고, 비디오 인코딩 실패 시 보관했던 데이터를 활용해 인코딩을 재개하도록 함 (= 분할된 비디오의 캐시 역할)

### DAG 스케줄러

DAG 그래프를 몇 개의 stage로 분할한 후, 그 각각을 자원 관리자의 작업 큐에 집어넣는다.

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/9c9b4cee-8b13-434f-8908-081c120f6f5d)

STEP1. 비디오, 오디오, 메타데이터를 분리

STEP2. 해당 비디오 파일을 인코딩하고 썸네일을 추출하며, 오디오 파일도 함께 인코딩

### 자원 관리자

자원 배분을 효과적으로 수행하는 역할 담당

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/488ddbed-64b5-4d52-8a67-592370752112)

- `작업 큐` (task queue) : 실행할 작업이 보관되어 있는 우선순위 큐
- `작업 서버 큐` (worker queue) : 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
- `실행 큐` (running queue) : 현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 큐
- `작업 스케줄러` : 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시하는 역할

[작업 관리자의 동작]

STEP1. 작업 큐에서 가장 높은 우선순위의 작업을 꺼냄

STEP2. 해당 작업을 실행하기 적합한 작업 서버를 고름

STEP3. 해당 작업 서버에게 작업 실행을 지시

STEP4. 해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣음

STEP5. 작업이 완료되면 해당 작업을 실행 큐에서 제거

### 작업 서버

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/98ef4ac7-5e08-4a23-b718-768f93873659)

DAG에 정의된 작업 수행 → 작업 종류에 따라 작업 서버도 구분하여 관리

### 임시 저장소

여러 저장소 시스템을 활용하여 임시 저장소를 구현할 수 있다. 어떤 시스템을 선택할 것인지는 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 달라진다. 

ex. 

- 메타데이터는 작업 서버가 빈번히 참조하는 정보이고 주로 크기가 작음 ⇒ 메모리에 캐시하는 것이 좋음!
- 비디오/오디오 데이터는 주로 크기가 큼 ⇒ BLOB 저장소에 두는 것이 바람직

임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제!

### 인코딩된 비디오

인코딩 파이프라인의 최종 결과물 (파일명 예시 - `funny_720p.mp4`)

</aside>

### 시스템 최적화

> 속도, 안전성, 비용 측면에서 시스템을 최적화해보자!
> 
- 속도
    1. 비디오 병렬 업로드
        
        하나의 비디오를 작은 GOP들로 분할하여 병렬적으로 업로드하면 일부가 실패해도 빠르게 업로드를 재개할 수 있고, 업로드 속도를 높일 수 있다
        
        *비디오 전부를 한 번의 업로드로 올리는 것은 비효율적
        
    2. 업로드 센터를 사용자 근거리에 지정
        
        CDN을 이용하는 등 업로드 센터를 여러 곳에 두면 속도를 개선할 수 있다
        
    3. 모든 절차를 병렬화
        
        느슨하게 결합된 시스템으로 병렬성을 높이는 것은 낮은 응답지연을 달성하는 것에 근접한 효과를 낼 수 있다. 
        
        → 이전 단계의 결과물이 입력으로 사용되는 구조 대신, 의존성을 줄일 수 있는 ‘**메시지 큐**’를 도입해보자!
        
        ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/f6aea55b-0ce3-4b6f-b614-4c6f2ad1393a)
        
        - 메시지 큐 도입 전 - 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야 한다
        - 메시지 큐 도입 후 - 인코딩 모듈은 다운로드 모듈의 작업이 끝나는지 여부와 상관없이, 메시지 큐에 보관된 이벤트 각각을 병렬적으로 처리할 수 있다
    
- 안전성
    1. 미리 사인된 업로드 URL (pre-signed url)
        
        허가받은(authorized) 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 PreSigned Url을 사용할 수 있다
        
        **[Flow]**
        
        ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/b74ab8ed-d023-40d4-bdeb-122c86117d56)
        
        1. 클라이언트 → HTTP 서버 : `POST` 요청으로 PreSigned Url 발급
            
            *이때 해당 url이 가리키는 객체에 대한 접근 권한은 이미 부여된 상태
            
            e.g Amazon S3의 Pre Signed Url, MS Azure의 Shared Access Signature
            
        2. API 서버 : PreSigned Url 반환
        3. 클라이언트 : 해당 url이 가리키는 위치에 비디오 업로드
    2. 비디오 보호
        
        인터넷에 업로드 하면서도 비디오의 저작권을 보호하려면 아래 선택지 중에 채택할 수 있다
        
        - 디지털 저작권 관리(DRM: Digital Rights Management) 시스템 도입
            
            e.g Apple의 FairPlay, 구글의 Widevine, MS의 PlayReady
            
        - AES 암호화 : 비디오를 암호화하고 접근 권한을 설정하는 방식
            
            → 암호화된 비디오는 재생 시에만 복호화 (허락된 사용자만 암호화된 비디오를 시청할 수 있음)
            
        - 워터마크 : 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 올리는 것

- 비용
    
    CDN은 세계 어디서도 끊김 없이 빠르게 비디오를 시청할 수 있도록 해주는 핵심적인 시스템의 일부이지만, 비용이 만만치 않다. 이를 줄이기 위해 최적화를 시도해야 한다. 
    
    HOW?  *“유튜브의 비디오 스트리밍은 롱테일 분포를 따른다”*
    
    = 인기 있는 비디오는 자주 재생되지만, 나머지는 거의 보는 사람이 없다는 의미
    
    1. 인기 비디오는 `CDN`을 통해 재생, 그 외는 `비디오 서버`를 통해 재생
        
        ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/4785b4fc-1c21-4e15-accc-2c03e1ad1b13)
        
    2. 인기가 없는 비디오는 인코딩 X
    3. 짧은 비디오는 필요한 시점에 인코딩
    4. 특정 지역에서만 인기가 높은 비디오는 다른 지역에 옮기지 X
    5. CDN 직접 구축 + ISP(인터넷 서비스 제공자)와 제휴

### 오류 처리

> 장애를 아주 잘 감내하는(highly fault-tolerant) 시스템을 만들기 위해서, 오류를 우아하게 처리하고 빠르게 회복해야 한다.
> 

**[시스템 오류 유형]**

- `회복 가능 오류`(recoverable error) : 특정 비디오 세그먼트를 트랜스코딩하다 실패했다는 등의 오류는 회복 가능한 오류에 속함
- `회복 불가능 오류`(non-recoverable error) : 비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 시스템은 해당 비디오에 대한 작업을 중단하고 클라이언트에게 적절한 오류 코드를 반환해야 함

**[시스템 컴포넌트 별 오류의 전형적인 해결방법]**

- 업로드 오류, 트랜스코딩 오류 → 재시도(retry)
- 비디오 분할 오류 → 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우, 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 함
- 전처리 오류 → DAG 그래프 재생성
- DAG 스케줄러 오류 → 작업을 다시 스케줄링
- 자원 관리자 큐에 장애 발생 → 사본 이용
- 작업 서버 장애 → 다른 서버에서 해당 작업을 재시도
- API 서버 장애 → API 서버는 stateless이므로, 신규 요청은 다른 API 서버로 우회
- 메타데이터 캐시 서버 장애 → 장애가 난 캐시 서버를 새로운 것으로 교체
    
    *데이터는 다중화되어 있으므로, 다른 노드에서 데이터를 가져올 수 있음
    
- 메타데이터 데이터베이스 서버 장애
    
    → 주 서버가 죽었다면, 부 서버 중 하나를 주 서버로 교체
    
    → 부 서버가 죽었다면, 다른 부 서버를 통해 읽기 연산 처리 및 죽은 서버는 새 것으로 교체
    

## 4단계 마무리

### 추가로 논의하면 좋은 주제

- API 계층의 규모 확장성 확보 방안 : API 서버가 stateless 이므로, 수평적 규모 확장이 가능하다는 점을 언급!
- 데이터베이스 계층의 규모 확장성 확보 방안 : 데이터베이스의 다중화와 샤딩 방법에 대해 논의
- 라이브 스트리밍 : 비디오를 실시간으로 녹화하고 방송하는 절차
    
    공통점 - 비디오 업로드, 인코딩, 스트리밍이 필요하다는 점
    
    차이점
    
    | 라이브 스트리밍 시스템 | 비-라이브 스트리밍 시스템 |
    | --- | --- |
    | 응답지연이 더 낮아야 함
    → 스트리밍 프로토콜 선정에 유의! | 응답지연이 비교적 높음 |
    | 병렬화 필요성 DOWN
    → 작은 단위의 데이터를 실시간으로 빨리 처리해야 하기 때문 | 병렬화 필요성 UP |
    | 오류 처리에 많은 시간이 걸리지 않도록 방법을 더욱 유의하여 선정 |  |
- 비디오 삭제(takedown) : 저작권을 위반한 비디오, 선정적 비디오, 불법적 행위에 관계된 비디오는 내려야 함
    
    (i) 업로드 과정에서 식별하거나 (ii) 사용자의 신고 절차를 통해 판별
