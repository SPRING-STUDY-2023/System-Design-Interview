# 12장. 채팅 시스템 설계
실생활에서 정말 다양한 채팅 시스템을 발견할 수 있다. (e.g. Whatsapp, 라인, 페이스북 메신저, 구글 행아웃, Discord, Wechat, 카카오톡 등)

따라서 채팅 앱을 설계하기 위해서는 요구사항을 정확히 파악해야 한다!

## 1단계  문제 이해 및 설계 범위 확정

<aside>
📲 채팅 앱 예시

- 1:1 채팅
    - WeChat
    - WhatsApp
- 그룹 채팅
    - Slack (업무용 앱)
- 게임 채팅
    - Discord (대규모 그룹의 소통 + 응답지연이 낮은 음성 채팅)
</aside>

### 요구사항 분석

- `지원` : 모바일 앱, 웹 앱 모두 지원
- `트래픽 규모` : DAU 기준 5천만 명 수용
- `인원 제한` : 그룹 채팅은 최대 100명까지 참가 가능
- `주요 기능`
    1. 사용자 접속상태 표시 지원 
    2. 응답지연(latency)이 낮은 1:1 채팅 
    3. 그룹 채팅 
    4. 텍스트 메시지만 가능 (첨부파일 X)
- `메시지 길이 제한` : 100,000자 이하
- `암호화` : 종단 간(end-to-end) 암호화 지원 가능
- `보관` : 영구적

**[정리]**

1. 사용자 접속상태 표시 기능
2. 응답지연(latency)이 낮은 1:1 채팅 
3. 최대 100명까지 참여 가능한 그룹 채팅
4. 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
5. 푸시 알림

## 2단계 개략적 설계안 제시 및 동의 구하기

[채팅 서비스의 기본 기능]

- 클라이언트들로부터 메시지 수신
- 메시지 수신자(recipient) 결정 및 전달
- 수신자가 접속(online) 상태가 아닌 경우, 접속될 때까지 해당 메시지 보관

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/6ccc0389-7963-4f5a-9ff1-3ec0a13ff3ec)

**[메시지 송신]**

1. 채팅을 시작하려는 클라이언트가 **`네트워크 통신 프로토콜`**을 통해 서비스에 접속
    
    *→ 어떤 프로토콜을 사용할 것인가?*
    
    HTTP가 가장 많이 사용되는 웹 프로토콜!  *클라이언트가 연결을 만드는 프로토콜 (클라이언트 → 서버로는 쉽지만, 서버 → 클라이언트 방향으로는 쉽지 않음)
    
2. 클라이언트가 프로토콜로 메시지를 수신자에게 전달하라고 알림
    
    *→ HOW?*
    
    keep-alive 헤더 사용
    
    - 클라이언트와 서버 사이의 연결을 끊지 않고 유지할 수 있음
    - TCP 접속 과정에서 발생하는 hand-shake 횟수를 줄일 수 있음

**[메시지 수신]**

서버 → 클라이언트로 임의의 시점에 메시지를 보내기 위해, 폴링, 롱 폴링, 웹 소켓 등의 기술을 활용할 수 있다. 

### 폴링(Polling)

> 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어보는 방법
> 

👎🏻 

- 비용은 폴링 횟수에 비례
- 답해줄 메시지가 없는 경우, 불필요하게 낭비되는 경우 多

### 롱 폴링(Long Polling)

> 클라이언트가 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지 → 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내서 다시 모든 절차를 시작하는 방법
> 

👎🏻 

- 메시지 송수신 클라이언트들이 같은 채팅 서버에 접속하지 않을 수도 있음
    
    → HTTP 서버는 Stateless 하며, 라운드 로빈 알고리즘을 사용하는 경우 롱 폴링 연결을 가지고 있지 않은 서버일 수 있음
    
- 서버 입장에서 클라이언트의 연결 여부를 확인할 수 없음
- 타임아웃 발생 시마다 서버에 주기적으로 다시 접속하므로 여전히 비효율적

### 웹 소켓(WebSocket)

> 서버 → 클라이언트로 비동기(async) 메시지를 보낼 때 가장 널리 사용하는 기술
> 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/5a783eaf-008b-461c-bae7-63fbf95463c1)

👍🏻

- 클라이언트가 연결을 시작
- 한번 맺어지면 항구적, 양방향 연결
- `HTTP` 연결로 시작 → 특정 handshake 절차를 거쳐 `웹소켓` 연결로 업그레이드
- 비동기 송수신 가능
- HTTP(80) / HTTPS(443) 포트번호를 그대로 사용하므로 방화벽이 있는 환경에서도 잘 동작
- 단순하고 직관적인 구현

👎🏻

- 웹소켓 연결 관리를 서버 측에서 효율적으로 할 필요가 있음

## 개략적 설계안

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/11fd1817-0d92-46fd-9a6f-422038012937)

- 무상태(stateless) 서비스 - `HTTP` 이용
- 상태 유지(stateful) 서비스 - `웹 소켓` 이용
- 제3자 서비스 연동

### 무상태 서비스

> 로그인, 회원가입, 사용자 프로필 표시 등을 처리하는 전통적인 요청/응답 서비스
> 

→ 많은 웹/앱 서비스에서 보편적으로 제공하는 기능

- **로드밸런서** 뒤에 위치
    - 요청을 알맞은 서비스 경로로 전달하는 역할 (monolithic / micro)

### 상태 유지 서비스

> Stateful이 필요한 서비스 = *only* 채팅 서비스
> 

→ 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 함

- 클라이언트는 서버가 죽지 않는 한 다른 서버로 연결을 변경하지 않음

### 제3자 서비스 연동

> 푸시 알림
> 

[10장 알림 시스템 설계](https://www.notion.so/10-11f3f5ad799749b8b8ebfebd4c4622e2?pvs=21) 참고

- 새 메시지를 받았을 때, 앱이 실행 중이지 않더라도 알림을 받아야 함

⇒ 서비스와의 통합이 매우 중요한 영역

- 서비스 탐색(service discovery) 서비스 - 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할
    - ⭐ 채팅 서비스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않게 함!

### 규모 확장성

*서버 한 대로 얼마나 많은 동시 접속을 허용할 수 있을까?*

→ 동시 접속자가 100만 명이라고 가정할 때, 접속 당 10KB의 서버 메모리가 필요하고, 10GB의 메모리만 있으면 모든 연결을 처리할 수 있다. 

BUT, SPOF(Single-Point-Of-Failure) 문제에 의해 대용량 트래픽은 여러 대의 서버로 분산시켜야 한다. 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/3d06804a-e81c-4b4c-8943-c3d19690e77a)

- 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
- 접속 상태 서버는 사용자의 접속 여부를 관리한다.
- API 서버는 로그인, 회원가입, 프로필 변경등 그 외 나머지 전부를 처리한다.
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소에 채팅 이력을 보관한다.

### 저장소

- 데이터 계층을 올바르게 구성해야 한다
- RDB vs NoSQL

⇒ 데이터의 유형과 읽기/쓰기 연산 패턴을 고려할 것

**[채팅 시스템에서 다루는 데이터]**

|  | 일반적인 데이터 | 채팅 시스템에 고유한 데이터 |
| --- | --- | --- |
| 예시 | 사용자 프로필, 설정, 친구 목록 등 | 채팅 이력(chat history) |
| 보관 | 관계형 데이터베이스(RDB)
+ 다중화, 샤딩을 통한 데이터의 가용성과 규모확장성 보증 | 키-값 저장소
→ 읽기/쓰기 연산 패턴을 고려하여 어떻게 보관할지 결정 |
- 채팅 이력 데이터의 양은 방대함
    - e.g. 페이스북 메신저, Whatsapp - 매일 600억(60billion) 개의 메시지를 처리함
- 가장 빈번하게 사용되는 것 - 최근에 주고받은 메시지
    - 사용자가 주로 보게되는 것 최근 주고받은 메시지이지만, 검색 기능, 특정 사용자 언급, 점프 등으로 과거의 무작위적인 데이터 접근도 이루어짐
    - 해당 부분까지 고려하여 데이터 계층을 구성해야 함
- 1:1 채팅 앱의 경우, 읽기:쓰기 = 1:1의 비율로 사용됨

<aside>
📎 키-값 저장소의 장점

- 수평적 규모확장(horizontal scaling)이 쉬움
- 데이터 접근 지연시간(latency)이 낮음
</aside>

관계형 DB는 데이터 중 long tail에 해당하는 부분을 잘 처리하지 못하는 경향이 있는데, 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 늘어나므로 불리하다.

따라서, 많은 안정적인 채팅 시스템은 키-값 저장소를 채택하고 있다!

- Facebook - HBase
- Discord - Cassandra

### 데이터 모델

*메시지 데이터를 어떻게 보관할까?!*

1:1 채팅을 위한 메시지 테이블

`PK` - message_id

- 메시지 순서를 쉽게 정할 수 있음
- 메시지를 식별할 수 있음

그룹 채팅을 위한 메시지 테이블

`PK` - (channel_id, message_id) 복합 키

- channel = 채팅 그룹에 대응
    
    → partition key로도 사용
    
- 그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 함

[공통 속성]

- message_id의 값은 고유해야 한다. (uniqueness)
- ID값은 정렬 가능하며, 시간 순서와 일치해야 한다. (점점 커지는 구조)

***HOW?***

1. RDBMS의 auto_increment 기능
    
    → NoSQL은 RDB와 달리, auto_increment 기능을 제공하지 않는다. 
    
2. Snowflake와 같은 전역적 64bit 순서 번호(sequence number) 생성기 
    
    → [7장 분산 시스템을 위한 유일 ID 생성기 설계](https://www.notion.so/7-ID-fe3a6c839dc64bdf838e52b0a036d000?pvs=21) 
    
3. 지역적 순서 번호 생성기
    - 지역적(local)이란?
        
        ID의 유일성은 같은 그룹 안에서만 보증하면 충분하다!
        
        → 메시지 사이의 순서가 같은 채널, 같은 1:1 채팅 세션 내에서만 유지되면 충분하기 때문
        
    - 전역적 ID 생성기에 비해 구현이 쉬운 접근법

## 3단계 상세 설계

*개략적 설계안에서 아래 주제를 더 깊이 탐구해보자!*

- 서비스 탐색
- 메시지 전달 흐름
- 사용자 접속 상태 표시 방법

### 서비스 탐색

> 주요 역할 - 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
> 

사용 가능한 모든 채팅 서버를 여기에 등록시켜두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라 주면 된다

**[기준]** 

- 클라이언트의 위치(geographical location)
- 서버의 용량(capacity)

**[오픈소스 솔루션]**

- Apache Zookeeper
    
    

**[동작 과정]**

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/eee41c71-9693-4d59-aaf9-6d7c0ff52fc2)

1. 사용자A가 시스템에 로그인을 시도한다.
2. 로드밸런서가 로그인 요청을 API 서버들 중 하나로 보낸다.
3. API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 해당 사용자A를 서비스할 최적의 채팅 서버를 찾는다. (⇒ 2개의 서버가 선택되어 사용자에 반환된 것)
4. 사용자A는 채팅 서버2와 웹소켓 연결을 맺는다. 

### 메시지 흐름

> 1:1 채팅 메시지 처리 흐름
> 

![1:1 채팅에서 사용자A → 사용자B로 보낸 메시지가 어떤 경로를 거치게 될까?](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/078f90bd-10df-449e-bf7c-07eb48413e3a)

1:1 채팅에서 사용자A → 사용자B로 보낸 메시지가 어떤 경로를 거치게 될까?

1. 사용자A가 채팅 서버1로 메시지 전송
2. 채팅 서버1은 ID 생성기를 사용해 해당 메시지의 ID 결정
3. 채팅 서버1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. 사용자B의 접속 여부에 따라
    1. 사용자B가 접속 중인 경우 메시지는 사용자B가 접속 중인 채팅 서버2로 전송됨
    2. 사용자B가 접속 중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
6. 채팅 서버2는 메시지를 사용자B에게 전송
7. 사용자B와 채팅 서버2 사이에는 웹소켓 연결이 있는 상태이므로 그것을 이용

> 여러 단말 사이의 메시지 동기화
> 

![여러 단말 사이에 메시지 동기화 흐름](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/732ef87c-6b23-4d9b-9d8c-a1a047e63635)

여러 단말 사이에 메시지 동기화 흐름

- 사용자A가 전화기에서 채팅 앱에 로그인한 결과로 채팅 서버1과 해당 단말 사이에 웹소켓 연결
- 랩톱에서 로그인한 결과로 별도 웹소켓이 채팅 서버1에 연결

→ 각 단말은 최신 메시지 ID를 추적하기 위한 `변수`를 유지

***어떤 걸 새 메시지로 간주할까?***

1. 수신자 ID == 현재 로그인한 사용자 ID
2. 키-값 저장소에 보관 & ID > `변수`에 저장한 ID

> 소규모 그룹 채팅에서의 메시지 흐름
> 

![[가정] 3명의 사용자가 있는 그룹 채팅방에서의 흐름](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/2ccd45a4-1e4f-4a79-98ad-ff6bd18d39bb)

[가정] 3명의 사용자가 있는 그룹 채팅방에서의 흐름

- 사용자A가 보낸 메시지는 사용자 B와 C의 메시지 동기화 큐에 복사됨
- 수신자 관점 | 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 한다.

→ 큐 = 사용자 각각에 할당된 메시지 수신함의 역할

→ 메시지 동기화 큐는 여러 사용자로부터 오는 메시지를 받을 수 있어야 한다

***소규모 채팅방에 더 적합한 방식이다***

1. 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되므로 메시지 동기화 플로우가 단순함
2. 그들이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않음

### 접속상태 표시

*접속상태 서버에서 사용자의 상태를 관리*

→ 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부

**[사용자의 상태가 바뀌는 시나리오]**

1. 사용자 로그인
    1. 클라이언트와 실시간 서비스 사이의 웹소켓 연결
    2. 접속상태 서버가 사용자의 상태와 최종 활성 일시에 대한 타임스탬프 값을 키-값 저장소에 보관
    3. 해당 사용자는 접속 중인 것으로 표시됨
2. 로그아웃
    1. 키-값 저장소에 보관된 사용자 상태가 online → offline으로 바뀜 
    2. 화면 상으로도 표시됨
3. 접속 장애
    
    > *인터넷을 통한 연결이 안정적이지 않은 경우, 장애를 어떻게 현명하게 대응할 것인가?*
    > 
    
    💡 가장 간단한 방법 - 사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경하는 것
    
    <aside>
    📌 박동 검사(heartbeat)
    
    온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 접속상태 서버로 보내도록 하고, 마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속상태를 계속 온라인으로 유지하는 것
    
    *그렇지 않을 경우에만 오프라인으로 바꾸는 것
    
    [예시]
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/f1def119-acd1-41c0-ac31-3a39242143fd)
    
    1. 클라이언트는 박동 이벤트를 5초마다 서버로 보낸다. 
    2. 이벤트를 3번 보낸 후, x=30초 동안 아무런 메시지를 보내지 않으면 오프라인 상태로 변경된다.
    </aside>
    

1. 상태 정보의 전송
    
    > *친구 관계에 있는 사용자들은 어떻게 서로의 상태 변화를 알아차릴 수 있을까?*
    > 
    
    상태정보 서버 = 발행-구독 모델(publish-subscribe model)
    
    ex. 사용자 A의 접속상태가 변경되면?
    
    각 사용자에서 구독하는 A-B, A-C, A-D (3개)의 채널로 해당 사실을 알림
    
    *실시간 웹소켓을 사용
    
    → 이 방안은 그룹 크기가 작을 때 효과적! (그룹의 크기가 커질수록 접속상태 변화를 알리는 데 비용과 시간이 많이 들게 되므로)
    

## 4단계 마무리

**[주요 컴포넌트 정리]**

- 실시간 통신 - 웹소켓
- 실시간 메시징 지원 - 채팅 서버, 접속상태 서버, 푸시 알림 서버
- 채팅 이력 보관 - 키-값 저장소
- 그 외 기능 - API 서버

**[논의하면 좋을 내용]**

- 채팅 앱을 확장하여 사진, 비디오 등의 미디어를 지원하도록 하는 방법 → 텍스트(채팅 메시지) 보다 크기가 큰 미디어 파일
    - 압축 방식
    - 클라우드 저장소
    - 썸네일 생성
- 종단 간 암호화 : 메시지 발신인과 수신자 외에는 아무도 메시지 내용을 볼 수 없다
- 캐시 : 클라이언트에 이미 읽은 메시지를 캐시해두면, 서버와 주고받는 데이터의 양을 줄일 수 있다
- 로딩 속도 개선
    
    ex. Slack - 사용자의 데이터, 채널을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선
    
- 오류 처리
    - 채팅 서버 오류 : 채팅 서버 하나가 죽으면 서비스 탐색 기능(e.g. 주키퍼)이 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록!
    - 메시지 재전송 : `retry`, `queue` - 메시지의 안정적 전송을 보장하기 위해 흔히 사용되는 기법
