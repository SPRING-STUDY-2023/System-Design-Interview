# 7장. 분산 시스템을 위한 유일 ID 생성기 설계
우리가 테이블을 설계할 때, 식별자의 역할을 하는 ID를 생성해야 한다. 

RDB의 기본키 auto_increment 속성을 사용하는 것을 가장 먼저 떠올릴 수 있지만, 분산 환경에서 여러 DB 서버가 존재하는 경우에 지연시간을 낮추기 어려워지고 요구를 감당하기 힘들다.

> ***분산 시스템에서 유일성이 보장되는 ID를 효과적으로 설계해보자!***
> 

## 1단계 문제 이해 및 설계 범위 확정

### ID의 특성 파악하기

- 유일하다.
- 정렬 가능하다.
- 시간의 흐름에 따라 값이 커질 수 있으나, 항상 1씩 증가해야 하는 것은 아니다.
- 숫자로만 구성된다.
- 초당 10,000 ID를 생성할 수 있는 시스템 규모를 갖춰야 한다.

## 2단계 개략적 설계안 제시 및 동의 구하기

우리가 고려해볼 수 있는 선택지는 다음과 같다.

- 다중 마스터 복제(multi-master replication)
- UUID(University Unique Identifier)
- 티켓 서버(ticket server)
- 트위터 스노플레이크(twitter snowflake) 접근법

### 다중 마스터 복제

> 데이터베이스의 auto_increment 기능 활용
> 

다만, 우리가 알고 있는 점과의 차이는 1씩 증가시키는 것이 아닐아 k만큼 증가시키는 것이다. 

**k : 현재 사용 중인 데이터베이스 서버의 수*

![**k = 2 ; ID가 2씩 증가** ](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/bf276d31-9c71-483d-97f8-78205b19818a)

**k = 2 ; ID가 2씩 증가** 

👍🏻 장점

- DB 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있으므로 규모 확장성 문제를 어느 정도 해결할 수 있다

👎🏻 단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다
- ID의 유일성은 보장되겠지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다

### UUID

> 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수 (ex. 09ce93e62-50b4-468d-bf8a-c07e1040bfb2)
> 

→ **충돌 가능성이 극히 낮다!**  따라서, 서버 간 조율 없이 독립적으로 생성이 가능하다. 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/214f751a-3541-4623-839d-88e7ebb1a7af)

👍🏻 장점

- UUID를 만드는 것은 단순하다
    - 서버 사이의 조율 필요 X
    - 동기화 이슈 無
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조 ⇒ 규모 확장이 쉽다

👎🏻 단점

- ID가 128비트로 같다
**이번 장에서의 요구사항은 64비트*
- ID를 시간순으로 정렬할 수 없다
- ID에 숫자가 아닌 값이 포함될 수 있다

### 티켓 서버

> auto_increment 기능을 갖춘 데이터베이스 서버(= 티켓 서버)를 중앙 집중형으로 하나만 사용하는 것
> 

*#플리커(Flickr)가 분산 기본 키(distributed primary key)를 만들어내기 위해 이용한 기술*

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/4e0dafc1-7c09-42ea-857e-e24bc039513a)

👍🏻 장점

- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다

👎🏻 단점

- 티켓 서버 = SPOF(Single-Point-of-Failure)
    - 장애가 발생하면, 해당 서버를 이용하는 모든 시스템이 영향을 받는다

### 트위터 스노플레이크 접근법

> ID를 바로 생성하는 대신, 각개격파 전략(divide and conquer)을 적용하여 생성해야 하는 ID의 구조를 여러 섹션으로 분할하는 것
> 

**트위터가 사용하는 독창적인 ID 생성 기법*

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/e55ab5b1-37d2-4677-9e88-6b59c05445d0)

- `사인(sign) 비트`
    
    1비트 할당 → 음수와 양수를 구별하는 데 사용
    
- `타임스탬프(timestamp)`
    
    41비트 할당 → 기원 시간(epoch) 이후 몇 밀리초가 경과했는지 나타내는 값
    
- `데이터센터 ID`
    
    5비트 할당 → 2^5=32 개 데이터센터 지원 가능
    
- `서버 ID`
    
    5비트 할당 → 데이터센터 당 32개 서버 사용 가능
    
- `일련번호`
    
    12비트 할당 → 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1씩 증가
    
    *이 값은 1밀리초가 경과할 때마다 0으로 초기화된다
    

## 3단계 상세 설계

위 구조에서 데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 시스템 운영 중에 바뀌지 않는다. (중간에 변경하면 ID 충돌이 발생할 수 있어 신중해야 한다!)

반면, 타임스탬프와 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다.

### 타임스탬프

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/fe2775cd-492c-4bc5-b19a-b2f6828953aa)

위 값은 이진 표현형태로부터 모든 UTC 시각을 추출할 수 있음을 의미하며, 41비트로 표현할 수 있는 타임스탬프의 최댓값은 2^41-1=2199023255551ms 이다. 

⇒ 따라서 이 ID 생성기는 69년동안만 정상 동작하며, 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 마이그레이션 해야 한다.

### 일련번호

2^12 = 4069개의 값을 가질 수 있으며, 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다. 

## 4단계 마무리

위 네 가지 방식 중 요구사항에 가장 적합한 것은 **스노플레이크**이다. 

추가적으로 아래의 논의 사항을 이야기해보면 좋겠다!

- **시계 동기화(clock synchronization)**
    
    실제로 ID 생성 서버들이 전부 같은 시계를 사용하는 것이 아닐 수 있다는 점을 알아두면 좋다.
    
    - 하나의 서버가 여러 코어에서 실행될 경우
    - 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우
    
    등에 시계 동기화는 꽤나 중요한 이슈이다. 
    
    → [NTP(Network Time Protocol)](https://en.wikipedia.org/wiki/Network_Time_Protocol)은 이 문제를 해결하는 가장 보편적인 수단이다!
    
- **각 절(section)의 길이 최적화**
    
    동시성이 낮고 수명이 긴 애플리케이션의 경우, 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있다.
    
- **고가용성(high availability)**
    
    ID 생성기는 필수 불가결(mission critical) 컴포넌트이므로, 아주 높은 가용성을 제공해야 한다.
