# 13장. 검색어 자동완성 시스템
> 가장 많이 이용된 검색어 k개를 자동완성하여 출력하는 시스템
> 

## 1단계 문제 이해 및 설계 범위 확정

### 요구사항

- 사용자가 입력하는 단어 - 자동완성될 검색어의 첫 부분으로 한정
- 자동완성 검색어 표시 개수 - 5개
- 자동완성 검색어를 고르는 기준 - 질의 빈도에 따라 정해지는 검색어 인기 순위
- 최대 수용가능 사용자 - DAU 기준 천만 명
- 기타
    - 지원O - 다국어 지원(모든 질의는 **영어 소문자로 이루어진다고 가정**)
    - 지원X - 맞춤법 검사 기능, 자동수정, 대문자/특수문자 처리

### 정리

- `빠른 응답 속도` : 사용자가 검색어를 입력함에 따라 자동완성 검색어도 빠르게 표시
    - ex. 페이스북 검색 - 시스템 응답속도 100ms 이내
- `연관성` : 자동완성이 출력되는 검색어는 사용자가 입력한 단어와 연관된 것
- `정렬` : 시스템의 계산 결과는 인기도 등의 순위 모델(ranking model)에 의해 정렬
- `규모 확장성` : 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 함
- `고가용성` : 시스템의 일부에 장애가 발생하거나, 느려지거나, 예상치 못한 네트워크 문제가 생겨도 시스템이 계속 사용 가능해야 함

### 개략적 규모 추정

- DAU는 천만 명으로 가정
- 평균적으로 한 사용자는 매일 10건의 검색을 수행한다고 가정
- 질의할 때마다 평균적으로 20byte의 데이터를 입력한다고 가정
    - 문자 인코딩 방법 : ASCII → 1문자 = 1byte
    - 질의문 : 평균적으로 4개 단어, 각 단어마다 다섯 글자로 이루어진다고 가정 ⇒ 질의당 평균 4x5=20byte
- 검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다
    - 평균적으로 1회 검색당 20건의 요청이 백엔드로 전달됨
    
    <aside>
    🔎 [예시] 검색창에 “dinner” 입력
    
    아래 6개의 요청이 순차적으로 백엔드에 전송된다.
    
    - search?q=d
    - search?q=di
    - search?q=din
    - search?q=dinn
    - search?q=dinne
    - search?q=dinner
    </aside>
    
- 대략 초당 24,000건의 질의(QPS)가 발생 ⇒ 10.000,000 사용자 X 10질의/일 X 20자/24시간/3600초
- 최대 QPS = QPS X 2 = 대략 48.000
- 질의 중 약 20%는 신규 검색어라고 가정 ⇒ 대략 0.4GB (= 10,000,000 사용자 X 10질의/일 X 20자 X 20%)
    - 매일 0.4 GB의 신규 데이터가 시스템에 추가된다

## 2단계 개략적 설계안 제시 및 동의 구하기

<aside>
💡 요약

- `데이터 수집 서비스` : 사용자가 입력한 질의를 실시간으로 수집하는 시스템
- `질의 서비스` : 주어진 질의에 다섯 개의 인기 검색어를 정렬하는 시스템
</aside>

### 데이터 수집 서비스(data gathering service)

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a8995d07-178f-45cc-a635-6bd906f001ab)

→ 사용자가 검색어를 입력하는 순서대로 상태가 위와 같이 바뀌어 나감

질의문과 사용빈도를 저장하는 빈도 테이블(frequency table)

- `query` : 질의문을 저장하는 필드
- `frequency` : 질의문이 사용된 빈도를 저장하는 필드

### 질의 서비스(query service)

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/dca01310-7688-4f44-b42c-4a4907a9594b)

검색어(ex. “`tw`”)를 입력하면 테이블의 Top 5 자동완성 검색어가 표시된다. 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/12281f3c-c48c-4e95-b2ca-a1a11b76c0c6)

→ 이 Top5는 빈도 테이블에 기록된 수치를 사용하여 계산한다고 가정

```sql
SELECT * FROM frequency_table
WHERE query LIKE 'prefix%'
ORDER BY frequency DESC
LIMIT 5
```

*데이터의 양이 많아진다면 DB가 병목이 될 수 있는 설계안 (best X)

## 3단계 상세 설계

<aside>
💡 컴포넌트

- 트라이(trie) 자료구조
- 데이터 수집 서비스
- 질의 서비스
- 규모 확장이 가능한 저장소
- 트라이 연산
</aside>

### 트라이 자료구조

> 트라이를 어떻게 최적화해야 응답 시간을 줄일 수 있을까?
> 

**트라이(trie) - 접두어 트리(prefix tree), retrieval*

**문자열들을 간략하게 저장할 수 있는 트리 형태의 자료구조**

![[예시] 질의어 “tree”, “try”, “true”, “toy”, “wish”, “win”이 보관된 트라이](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/6770d617-07b1-4246-8ba3-707e89f939bb)

[예시] 질의어 “tree”, “try”, “true”, “toy”, “wish”, “win”이 보관된 트라이

- 트리의 `루트 노드` : 빈 문자열을 나타냄
- 각 `노드` : 글자 하나를 저장
    
    → **26개**(해당 글자 다음에 등장할 수 있는 모든 글자의 개수)의 자식 노드를 가질 수 있음
    
- 각 `트리 노드` : 하나의 단어 or 접두어 문자열(prefix string)을 나타냄

기본 트라이 자료구조는 노드에 문자들을 저장하는 형태이며, 이용 빈도 정보 (e.g. 빈도 테이블)는 아래와 같이 트라이 노드에 저장할 수 있다. 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/f9722ef8-b670-4024-aed5-d52f6246069f)

<aside>
📓 용어 정리

- *p* : 접두어(prefix)의 길이
- *n* : 트라이 안에 있는 노드 개수
- *c* : 주어진 노드의 자식 노드 개수
- *k* : 가장 많이 사용된 질의어 개수
</aside>

**[가장 많이 사용된 질의어 k개를 찾는 플로우]**

- 해당 접두어를 표현하는 노드를 찾는다
    - 시간 복잡도: O(p)
- 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다
    - `유효 노드` : 유효한 검색 문자열을 구성하는 노드
    - 시간 복잡도 : O(c)
- 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다
    - 시간 복잡도 : O(clogc)
    

⇒ 전체 시간 복잡도 : O(p) + O(c) + O(clogc)

<aside>
📎 예시 - k=2이고 사용자가 검색창에 ‘be’를 입력한 상황

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/abed8f43-942e-49cd-95d9-9ae63260f5f6)

1. 접두어 노드 ‘be’를 찾는다
2. 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다
    
    → 유효 노드 : [beer: 10], [best: 35], [bet: 29]
    
3. 유효 노드를 정렬하여 2개만 골라낸다
    
    [best: 35], [bet: 29] - 접두어 “tr”에 대해 검색된 2개의 인기 검색어
    
</aside>

알고리즘의 최악의 경우는 k개의 결과를 얻기 위해 트리 전체를 순회하는 것이다. 

이를 개선하기 위한 방안은 아래 두 가지가 존재한다.

1. **접두어 최대 길이 제한**
    
    사용자가 어차피 긴 검색어를 입력하는 일이 드물기 때문에, 검색어의 최대 길이를 제한한다면 “접두어 노드를 찾는” 단계의 시간 복잡도가 O(p) → O(1)까지 줄을 수 있을 것이다
    
2. **노드에 인기 검색어 캐시**
    
    각 노드에 k개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지할 수 있다. 
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a356b132-a90c-461a-9426-281abe297b3c)
    
    위와 같이 각 노드에 인기 질의어를 캐시하여 ‘Top 5’ 검색어를 질의하는 시간 복잡도를 낮출 수 있다. → 이는 각 노드에 더 많은 저장 공간을 필요로 한다는 말이기도 하지만, 빠른 응답속도가 중요한 상황에는 이 정도의 trade-off를 감수할 만하다
    

위 최적화 기법을 적용하면, 다음과 같은 효과를 기대할 수 있다.

- 접두어 노드를 찾는 시간 복잡도는 O(1)로 바뀐다
- 최고 인기 검색어 5개를 찾는 질의의 시간 복잡도도 O(1)로 바뀐다 (검색 결과가 이미 캐시되어 있으므로)

⇒ 전체 시간 복잡도 역시 O(1)로 최적화된다

### 데이터 수집 서비스

사용자가 검색창에 무언가 타이핑을 할 때 실시간으로 데이터를 수정하는 방식은 아래 2가지 문제점이 있다.

1. 매일 수천만 건의 질의가 입력될 때마다 트라이를 갱신하면, 질의 서비스의 속도는 심각하게 느려진다
2. 일단 트라이가 만들어지고 나면, 인기 검색어는 그리 자주 바뀌지 않으므로 자주 갱신할 필요도 없다

****트라이를 만드는 데 쓰이는 데이터는 보통 데이터 분석 서비스나 로깅 서비스로부터 올 것***

![데이터 분석 서비스의 컴포넌트](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/8c656b2a-bf59-46d8-be0f-e5cb73006e5a)

데이터 분석 서비스의 컴포넌트

- `데이터 분석 서비스 로그` : 검색창에 입력된 질의에 관한 원본 데이터가 보관된다
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a96fc560-7284-499c-abda-0084704ccb60)
    
    - 새로운 데이터 추가 (O), 수정 (X)
    - 로그 데이터에는 인덱스를 걸지 않는다
- `로그 취합 서버` : 방대하고 제각각인 형식의 로그 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 하는 역할
    - 데이터 취합 주기는 서비스의 목적에 맞게 지정해야 한다
        
         ex. 실시간 데이터 - 짧은 주기 , 대부분 - 일주일 주기
        
- `취합된 데이터`
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/cc719994-41b2-43a2-ba15-eb4fdbd8990e)
    
    - `time` : 해당 주가 시작한 날짜
    - `frequency` : 해당 질의가 해당 주에 사용된 횟수의 합
- `작업 서버` (worker) : 주기적으로 비동기적 작업을 싷행하는 서버 집합
    
    → 트라이 자료구조를 만들고 트라이 DB에 저장하는 역할
    
- `트라이 캐시` : 분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 구실을 함
    - 매주 트라이 DB의 스냅샷을 떠서 갱신한다
- `트라이 데이터베이스` : 지속성 저장소
    
    [가능한 선택지]
    
    1. 문서 저장소 : 새 트라이를 매주 만들어, 주기적으로 트라이를 직렬화하고 DB에 저장할 수 있다 (ex. MongoDB)
    2. 키-값 저장소 : 해시 테이블 형태로 변환하여 저장
        - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
        - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환
        
        ⇒ **각 트라이 노드는 하나의 <키, 값> 쌍으로 변환된다**
        
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/ea1be3eb-f4d0-4afa-92a9-4955e93db52b)
    

### 질의 서비스

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/bfc1db39-da54-4ff9-904d-1aaa42a50280)

> DB를 활용하여 최고 인기 검색어 다섯 개를 골라내자!
> 
1. 검색 질의가 로드밸런서로 전송된다
2. 로드밸런서가 해당 질의를 API 서버로 보낸다
3. API 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다
4. 데이터가 트라이 캐시에 없는 경우에는 데이터를 DB에서 가져와 캐시에 채운다
    
    → 다음에 같은 접두어에 대한 질의가 왔을 때, 캐시에 보관된 데이터를 사용해 처리할 수 있다!
    

질의 서비스는 매우 빨라야 하므로, 다음과 같은 최적화 방안을 생각해볼 수 있다.

- `AJAX 요청` : 웹 애플리케이션에서 브라우저가 자동완성된 검색어 목록을 가져오는 방식 ⇒ 새로고침 필요 X
- `브라우저 캐싱` : 대부분 자동완성 검색어 제안 결과가 짧은 시간 내에 바뀌지 않으므로, 제안된 검색어들을 브라우저 캐시에 넣어두면 후속 질의 결과는 해당 캐시에서 바로 가져갈 수 있다
    - 구글 검색엔진이 사용하는 캐시 메커니즘 - “제안된 검색어를 한 시간 동안 캐시해둔다”
        
        ```bash
        cache-control: private,max-age=3600
        ```
        
        `private` : 해당 응답이 요청을 보낸 사용자의 캐시에만 보관될 수 있다
        
        `max-age=3600` : 해당 캐시 항목은 3600초(=1시간) 동안만 유효하다
        
- `데이터 샘플링` : 모든 질의 결과를 로깅하는 대신, CPU 자원과 저장공간을 절약하지 위해 N개 요청 중 1개만 로깅하도록 하는 것

### 트라이 연산

- 트라이 생성 : 작업 서버가 담당 → 데이터 분석 서비스의 로그나 DB로부터 취합된 데이터 이용
- 트라이 갱신
    1. 매주 한 번 갱신하는 방법 : 새로운 트라이 생성 후, 기존 트라이를 대체
    2. 트라이의 각 노드를 개별적으로 갱신하는 방법 : 트라이 노드가 갱신할 때, 해당 노드의 모든 상위 노드들 기록도 갱신 (상위 노드에는 인기 검색어 질의 결과가 보관되기 때문!)
        
        *트라이가 작을 떄 고려해볼만 하지만, 성능상으로 그리 좋지 않음
        
- 검색어 삭제 : 트라이 캐시 앞에 필터 계층을 두고, 부적절한 질의어가 반환되지 않도록 하는 것
    - 👍🏻 필터 규칙에 따라 검색 결과가 자유롭게 변경될 수 있음
    - DB에서 해당 검색어를 물리적으로 삭제하려면, 다음번 업데이트 사이클에 비동기적으로 진행

### 저장소 규모 확장

영어만 지원하면 되므로, 첫 글자를 기준으로 샤딩하는 방법을 떠올릴 수 있다. 

- 검색어를 보관하는 서버가 2대라면?
    - ‘a’~’m’의 글자로 시작하는 검색어는 첫 번쨰 서버에, 나머지 ‘n’~’z’ 는 두 번째 서버에 저장
    - 3대라면, ‘a’~’i’ / ‘j’~’r’ / ‘s’~’z’

이 방법은 사용 가능한 서버의 최대 수가 26대로 제한된다. 

- 더 늘리려면? `계층별 샤딩` 필요
    
    검색어츼 첫 번째 글자는 첫 번째 레벨의 샤딩에, 두 번째 글자는 두 번째 레벨의 새딩에 쓰기
    
    ‘aa’~’ag’ / ‘ah’~’an’ / ‘ao’~’au’ / … 
    

하지만 데이터의 분포가 균등하지 않은 경우를 고려해야 하므로, 과거 질의 데이터 패턴을 분석하여 샤딩하는, ‘`검색어 대응 샤드 관리자`’ 방식도 존재한다

→ 어떤 검색어가 어느 저장소 서버에 저장되는지에 대한 정보를 관리

ex. ‘s’로 시작하는 검색어 양이 많다면, ‘s’ / ‘u’~’z’ 로 샤드 분할

## 4단계 마무리

> *다국어 지원 시스템으로 확장한다면?*
> 
- 유니코드(unicode) 데이터 저장
- 국가별 인기 검색어 순위가 다른 경우
    
    국가별로 다른 트라이를 사용하도록 하고, 트라이를 CDN에 저장하여 응답속도를 높이는 방법을 고려해볼 수 있다
    

> *실시간으로 변하는 검색어의 추이를 반영한다면?*
> 
- 새로운 뉴스 이벤트가 생기는 등 특정 검색어의 인기가 갑자기 높아질 경우, 시의적절하게 트라이를 갱신할 필요가 있다
- 또한, 트라이를 구성하는 데 너무 많은 시간이 소요될 것이므로 이에 대한 대안도 필요하다.

### 추가로 고려해볼 만한 아이디어

1. 샤딩을 통해 작업 대상 데이터의 양을 줄인다
2. 순위 모델을 바꾸어 최근 검색어에 보다 높은 가중치를 주도록 한다
3. 데이터가 스트림 형태로 올 수 있다는 점, 한번에 모든 데이터를 동시에 사용할 수 없을 가능성이 있다는 점을 고려해야 함
    
    *스트리밍 = 데이터가 지속적으로 생성됨을 의미 → 스트림 프로세싱 시스템이 추가적으로 필요!
    
    ex. Apache Hadoop MapReduce, Apache Spark Streaming, Apache Storm, Apache Kafka
