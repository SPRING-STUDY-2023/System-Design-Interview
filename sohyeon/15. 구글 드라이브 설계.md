# 15장 구글 드라이브 설계

## 1️⃣ 문제 이해 및 설계 범위 확정
```
지원자: 가장 중요하게 지원해야 할 기능들은 무엇인가요?
면접자: 파일 업로드/다운로드, 파일 동기화, 그리고 알림입니다.

지원자: 모바일 앱이나 웹 앱 가운데 하나만 지원하면 되나요, 아니면 둘 다 지원해야 합니까?
면접자: 둘 다 지원해야 합니다.

지원자: 파일을 암호화해야 할까요?
면접자: 네.

지원자: 파일 크기에 제한이 있습니까?
면접관: 10GB 제한이 있습니다.

지원자: 사용자는 얼마나 됩니까?
면접관: 일간 능동 사용자 기준으로 천만명입니다.
```

<br/>

**기능적 요구사항**
- 파일 추가
- 파일 다운로드
- 여러 단말에 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시

<br/>

**비기능적 요구사항**
- 안정성
- 빠른 동기화 속도
- 네트워크 대역폭
- 규모 확장성
- 높은 가용성

<br/>

### 개략적 추정치
- 가입 사용자는 오천만명이고 천만명의 DAU 사용자가 있다고 가정
- 모든 사용자에게 10GB의 무료 저장공간 할당
- 매일 각 사용자가 평균 2개의 파일을 업로드한다고 가정
- 읽기:쓰기 비율은 1:1
- 필요한 저장공간 총량 = 5천만 사용자 * 10GB = 500Petabyte
- 업로드 API QPS = 1천만 사용자 * 2회 업로드 / 24시간 / 3600초 = 약 240
- 최대 QPS = QPS * 2 = 480

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기
- 파일을 올리고 다운로드 하는 과정을 처리할 웹 서버
- 사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 데이터베이스
- 파일을 저장할 저장소 시스템

<br/>

<img width="601" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/9bc6eb1d-0b89-461d-b85c-5192e34ee6e2">

🔼 drive/디렉토리에 실제 파일이 보관된 사례
- 각 네임스페이스(하위 디렉토리) 안에는 특정 사용자가 올린 파일이 보관된다.
- 각 파일과 폴더는 그 상대 경로를 네임스페이스 이름과 결합하면 유일하게 식별해 낼 수 있다.

<br/>

### API
1. 파일 업로드 API
   - 단순 업로드 (작은 크기의 파일)
   - 이어 올리기 (큰 크기의 파일 or 네트워크 문제가 예상될 때)
2. 파일 다운로드 API
3. 파일 갱신 히스토리 API

<br/>

### 한 대 서버의 제약 극복

<img width="422" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/596d8b45-a349-461d-bdef-1c6caa2eb8b0">

🔼 샤딩(sharding)
- 여러 서버에 나누어 저장한다.

<br/>

<img width="739" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/f94250b8-e4ad-4bfd-abf5-caa69a4a2d2c">

🔼 데이터 다중화 (아마존 S3 서비스 활용)
- (왼쪽) 같은 지역 안에서 가능하다.
- (오른쪽) 여러 지역에 걸쳐 다중화하면 데이터 손실을 막고 가용성을 최대한 보장할 수 있다.

<br/>

**개선 부분**
- 로드밸런서: 네트워크 트래픽 분산
- 웹 서버: 로드밸런서를 두면 추가함으로써 트래픽 증폭에 쉽게 대응 가능
- 메타데이터 데이터베이스: SPOF 회피
- 파일 저장소

<br/>

<img width="373" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/c2a81249-9343-4a26-b4c1-1bef1d531742">

🔼 수정한 설계안

<br/>

### 동기화 충돌

<img width="767" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/3c757a87-123b-4876-841f-f8599e407289">

🔼 먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시한 사례
- 오류가 발생한 시점에 같은 파일의 2가지 버전이 존재한다. (사용자2의 로컬 사본, 서버에 있는 최신 버전)

<br/>

### 개략적 설계안

<img width="706" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/58eb65bd-3b23-4705-8b00-904d6db66555">

🔼 개략적 설계안
- 사용자 단말: 사용자가 이용하는 웹브라우저, 모바일 앱 등의 클라이언트
- 블록 저장소 서버(block server): 파일 블록을 클라우드 저장소에 업로드하는 서버 (파일을 여러 개의 블록으로 나눠 저장)
- 클라우드 저장소: 파일은 블록 단위로 나눠져 클라우드 저장소에 보관된다.
- 아카이빙 저장소: 오랫동안 사용하지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템
- 로드밸런서: 요청을 모든 API 서버에 고르게 분산하는 구실
- API 서버: 파일 업로드 외에 거의 모든 것을 담당하는 서버
- 메타데이터 데이터베이스: 사용자, 파일, 블록, 버전 등의 메타데이터 정보 관리
- 메타데이터 캐시: 성능을 높이기 위해 자주 쓰이는 메타데이터를 캐시
- 알림 서비스: 특정 이벤트가 발생했음을 클라이언트에게 알리는데 쓰이는 발생/구독 프로토콜 기반 시스템
- 오프라인 사용자 백업 큐: 클라이언트가 파일의 최신 상태를 확인할 수 없을 때 해당 정보를 큐에 두어 후에 접속했을 때 동기화될 수 있도록 한다.

<br/>

## 3️⃣ 상세 설계
### 블록 저장소 서버
- 파일 업로드에 관계된 힘든 일을 처리한다.
  - 각 블록에 압축 알고리즘 적용
  - 암호화
  - 수정된 블록만 전송

<br/>

**최적화 방법**
- 델타 동기화: 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화한다.
- 압축: 블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있다.

<br/>

<img width="674" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/7ca30dd3-0331-4770-97a3-509db30275df">

🔼 블록 저장소 서버 동작 과정
- 주어진 파일을 작은 블록들로 분할한다.
- 각 블록을 압축한다.
- 클라우드 저장소로 보내기 전에 암호화한다.
- 클라우드 저장소로 보낸다.

<br/>

<img width="566" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/7fd9d98e-8c6e-4b5e-8472-0081b951ee7d">

🔼 델타 동기화 전략 동작
- 갱신된 부분만 동기화한다.

<br/>

### 높은 일관성 요구사항
- 캐시에 보관된 사본과 데이터베이스에 있는 원본이 일치한다.
- 데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 없는 사본을 무효화한다.

<br/>

### 메타데이터 데이터베이스

<img width="724" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/e6f8c81a-47ba-4dae-a363-1c2c0f30da2c">

🔼 데이터베이스 설계안
- user: 사용자에 관계된 기본적 정보들이 보관된다.
- device: 단말 정보가 보관된다.
- namespace: 사용자의 루트 디렉토리 정보가 보관된다.
- file: 파일의 최신 정보가 보관된다.
- file_version: 파일의 갱신 이력이 보관된다. (읽기 전용)
- block: 파일 블록에 대한 정보를 보관한다.

<br/>

### 업로드 절차

<img width="664" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/31e8bf3f-f4f3-4778-ba3d-837501850e77">

🔼 시퀀스 다이어그램
- 파일 메타데이터 추가
  1. 클라이언트1이 새 파일의 메타데이터를 추가하기 위한 요청 전송
  2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기 중으로 변경
  3. 새 파일이 추가되었음을 알림 서비스에 통지
  4. 알림 서비스는 관련된 클라이언트(클라이언트2)에게 파일이 업로드되고 있음을 알림
- 파일을 클라우드 저장소에 업로드 (2)
  1. 클라이언트1이 파일을 블록 저장소 서버에 업로드
  2. 블록 저장소 서버는 파일을 블록 단위로 쪼갠 다음 압축하고 암호화한 다음에 클라우드 저장소에 전송
  3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출 (콜백 호출은 API 서버로 전송)
  4. 메타데이터 DB에 기록된 해당 파일의 상태를 완료로 변경
  5. 알림 서비스에 파일 업로드가 끝났음을 통지
  6. 알림 서비스는 관련된 클라이언트(클라이언트2)에게 파일 업로드가 끝났음을 알림
 
<br/>

### 다운로드 절차
- 클라이언트A가 접속 중이고 다른 클라이언트가 파일을 변경하면 알림 서비스가 클라이언트A에게 새 버전이 필요함을 알린다.
- 클라이언트A가 네트워크 연결 중이 아니면 데이터는 캐시에 보관된다. 접속할 때 클라이언트는 새 버전을 가져간다.

<br/>

<img width="614" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/388b1e56-3a74-4ae7-b405-a2cc488eeb07">

🔼 파일 다운로드 흐름
1. 알림 서비스가 클라이언트2에게 누군가 파일을 변경했음을 알린다.
2. 알림을 확인한 클라이언트2는 새로운 메타데이터를 요청한다.
3. API 서버는 메타데이터 데이터베이스에게 새 메타데이터를 요청한다.
4. API 서버에게 새 메타데이터가 반환된다.
5. 클라이언트2에게 새 메타데이터가 반환된다.
6. 클라이언트2는 새 메타데이터를 받는 즉시 블록 다운로드 요청을 전송한다.
7. 블록 저장소 서버는 클라우드 저장소에서 블록을 다운로드한다.
8. 클라우드 저장소는 블록 서버에 요청된 블록을 반환한다.
9. 블록 저장소 서버는 클라이언트에게 요청된 블록을 반환하고, 클라이언트2는 전송된 블록을 사용하여 파일을 재구성한다.

<br/>

### 알림 서비스
- **롱 폴링**: 드롭박스가 해당 방식을 채택하고 있다.
  - 양방향 통신이 필요하지 않음
  - 해당 다운로드 작업이 끝났거나 연결 타임아웃 시간에 도달한 경우에는 즉시 새 요청을 보내 롱 폴링 연결을 복원하고 유지해야 함
- 웹소켓: 클라이언트와 서버 사이에 지속적인 통신 채널을 제공한다. (양방향 통신 가능)

<br/>

### 저장소 공간 절약
- 중복 제거: 중복된 파일 블록을 계정 차원에서 제거한다. (해시 값 비교)
- 지능적 백업 전략 도입
  - 한도 설정: 보관해야 하는 파일 버전 개수에 제한
  - 중요한 버전만 보관
- 자주 쓰이지 않는 데이터는 아카이빙 저장소로 이동: 몇달 혹은 수년간 이용하지 않은 데이터가 해당 (S3 이용료보다 훨씬 저렴)

<br/>

### 장애 처리
- 로드밸런서 장애: 부 로드밸런서가 활성화되어 트래픽을 이어받아야 한다.
- 블록 저장소 서버 장애: 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아야 한다.
- 클라우드 저장소 장애: 한 지역에 장애가 발생했다면 다른 지역에서 파일을 가져오면 된다.
- API 서버 장애: 트래픽을 해당 서버로 보내지 않음으로써 장애 서버를 격리한다.
- 메타데이터 캐시 장애: 한 노드에 장애가 생기면 다른 노드에서 데이터를 가져온다.
- 메타데이터 데이터베이스 장애
  - 주 데이터베이스 서버 장애: 부 데이터베이스 서버 중 하나를 주로 올린다.
  - 부 데이터베이스 서버 장애: 다른 부 데이터베이스 서버에 읽기 연산을 맡기고 새 것으로 교체한다.
- 알림 서비스 장애: 롱 폴링 연결을 복구하는 것은 상대적으로 느릴 수 있다. (수백만명을 접속 유지는 가능하지만, 시작은 어려움)
- 오프라인 사용자 백업 큐 장애: 구독 중인 클라이언트들은 백업 큐로 구독 관계를 재설정한다.

<br/>

## 4️⃣ 마무리
블록 저장소 서버를 거치지 않고 파일을 클라우드 저장소에 직접 업로드한다면? (업로드 속도 향상)
- 분할, 압축, 암호화 로직을 클라이언트에 두어야 하므로 플랫폼별로 따로 구현해야 한다.
- 클라이언트가 해킹 당할 가능성이 있으므로 암호화 로직을 클라이언트 안에 두는 것은 적절하지 않을 수 있다.
