# 15장 구글 드라이브 설계

## 1️⃣ 문제 이해 및 설계 범위 확정
```
지원자: 가장 중요하게 지원해야 할 기능들은 무엇인가요?
면접자: 파일 업로드/다운로드, 파일 동기화, 그리고 알림입니다.

지원자: 모바일 앱이나 웹 앱 가운데 하나만 지원하면 되나요, 아니면 둘 다 지원해야 합니까?
면접자: 둘 다 지원해야 합니다.

지원자: 파일을 암호화해야 할까요?
면접자: 네.

지원자: 파일 크기에 제한이 있습니까?
면접관: 10GB 제한이 있습니다.

지원자: 사용자는 얼마나 됩니까?
면접관: 일간 능동 사용자 기준으로 천만명입니다.
```

<br/>

**기능적 요구사항**
- 파일 추가
- 파일 다운로드
- 여러 단말에 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시

<br/>

**비기능적 요구사항**
- 안정성
- 빠른 동기화 속도
- 네트워크 대역폭
- 규모 확장성
- 높은 가용성

<br/>

### 개략적 추정치
- 가입 사용자는 오천만명이고 천만명의 DAU 사용자가 있다고 가정
- 모든 사용자에게 10GB의 무료 저장공간 할당
- 매일 각 사용자가 평균 2개의 파일을 업로드한다고 가정
- 읽기:쓰기 비율은 1:1
- 필요한 저장공간 총량 = 5천만 사용자 * 10GB = 500Petabyte
- 업로드 API QPS = 1천만 사용자 * 2회 업로드 / 24시간 / 3600초 = 약 240
- 최대 QPS = QPS * 2 = 480

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기
- 파일을 올리고 다운로드 하는 과정을 처리할 웹 서버
- 사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 데이터베이스
- 파일을 저장할 저장소 시스템

<br/>

<img width="601" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/9bc6eb1d-0b89-461d-b85c-5192e34ee6e2">

🔼 drive/디렉토리에 실제 파일이 보관된 사례
- 각 네임스페이스(하위 디렉토리) 안에는 특정 사용자가 올린 파일이 보관된다.
- 각 파일과 폴더는 그 상대 경로를 네임스페이스 이름과 결합하면 유일하게 식별해 낼 수 있다.

<br/>

### API
1. 파일 업로드 API
   - 단순 업로드 (작은 크기의 파일)
   - 이어 올리기 (큰 크기의 파일 or 네트워크 문제가 예상될 때)
2. 파일 다운로드 API
3. 파일 갱신 히스토리 API

<br/>

### 한 대 서버의 제약 극복

<img width="422" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/596d8b45-a349-461d-bdef-1c6caa2eb8b0">

🔼 샤딩(sharding)
- 여러 서버에 나누어 저장한다.

<br/>

<img width="739" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/f94250b8-e4ad-4bfd-abf5-caa69a4a2d2c">

🔼 데이터 다중화 (아마존 S3 서비스 활용)
- (왼쪽) 같은 지역 안에서 가능하다.
- (오른쪽) 여러 지역에 걸쳐 다중화하면 데이터 손실을 막고 가용성을 최대한 보장할 수 있다.

<br/>

**개선 부분**
- 로드밸런서: 네트워크 트래픽 분산
- 웹 서버: 로드밸런서를 두면 추가함으로써 트래픽 증폭에 쉽게 대응 가능
- 메타데이터 데이터베이스: SPOF 회피
- 파일 저장소

<br/>

<img width="373" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/c2a81249-9343-4a26-b4c1-1bef1d531742">

🔼 수정한 설계안

<br/>

### 동기화 충돌

<img width="767" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/3c757a87-123b-4876-841f-f8599e407289">

🔼 먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시한 사례
- 오류가 발생한 시점에 같은 파일의 2가지 버전이 존재한다. (사용자2의 로컬 사본, 서버에 있는 최신 버전)

<br/>

### 개략적 설계안

<img width="706" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/58eb65bd-3b23-4705-8b00-904d6db66555">

🔼 개략적 설계안
- 사용자 단말: 사용자가 이용하는 웹브라우저, 모바일 앱 등의 클라이언트
- 블록 저장소 서버(block server): 파일 블록을 클라우드 저장소에 업로드하는 서버 (파일을 여러 개의 블록으로 나눠 저장)
- 클라우드 저장소: 파일은 블록 단위로 나눠져 클라우드 저장소에 보관된다.
- 아카이빙 저장소: 오랫동안 사용하지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템
- 로드밸런서: 요청을 모든 API 서버에 고르게 분산하는 구실
- API 서버: 파일 업로드 외에 거의 모든 것을 담당하는 서버
- 메타데이터 데이터베이스: 사용자, 파일, 블록, 버전 등의 메타데이터 정보 관리
- 메타데이터 캐시: 성능을 높이기 위해 자주 쓰이는 메타데이터를 캐시
- 알림 서비스: 특정 이벤트가 발생했음을 클라이언트에게 알리는데 쓰이는 발생/구독 프로토콜 기반 시스템
- 오프라인 사용자 백업 큐: 클라이언트가 파일의 최신 상태를 확인할 수 없을 때 해당 정보를 큐에 두어 후에 접속했을 때 동기화될 수 있도록 한다.

<br/>

## 3️⃣ 상세 설계
### 블록 저장소 서버
