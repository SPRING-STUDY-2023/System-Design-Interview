# 6장 키-값 저장소 설계
- 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스이다.
- 저장소에 저장되는 값은 고유 식별자를 키로 가진다.
- 키와 값 사이의 연결 관계를 `키-값` 쌍이라고 지정한다.
- 키-값 쌍에서의 키는 유일해야 하며 해당 키에 매달린 값은 키를 통해서만 접근할 수 있다.
- 성능상의 이유로 키는 짧을수록 좋다.
- `키`는 일반 텍스트일 수도, 해시 값일 수도 있다.
- `값`은 문자열일 수도, 리스트일 수도, 객체일 수도 있다.
- Ex) 아마존 다이나모, memcached, 레디스 등

<br/>

🔽 키 값 저장소에 보관된 데이터의 사례

<img width="350" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/9593f931-3e93-423b-af3b-3d0c1af60dc0">

- put(key, value): 키-값 쌍을 저장소에 저장한다.
- get(key): 인자로 주어진 키에 매달린 값을 꺼낸다.

<br/>

## 문제 이해 및 설계 범위 확정

키-값 저장소의 특성
- 키-값 쌍의 크기는 10KB 이하이다.
- 큰 데이터를 저장할 수 있어야 한다.
- 높은 가용성을 제공해야 한다. 시스템에 장애가 생겨도 빨리 응답해야 한다.
- 높은 규모 확장성을 제공해야 한다. 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이뤄져야 한다.
- 데이터 일관성 수준은 조정이 가능해야 한다.
- 응답 지연시간이 짧아야 한다.

<br/>

## 단일 서버 키-값 저장소
- 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 방법은 가장 직관적이다.
  - 👍 빠른 속도 보장
  - 👎 모든 데이터를 메모리 안에 두는 것이 불가능할 수 있음
- 위 문제를 해결하기 위한 개선책
  - 데이터 압축
  - 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장
- 결국은 한 대 서버로 부족한 때가 있다. 많은 데이터를 저장하기 위해 분산 키-값 저장소가 필요하다.

<br/>

## 분산 키-값 저장소
- **분산 해시 테이블**이라고도 한다.
- 키-값 쌍을 여러 서버에 분산시킨다.

<br/>

### CAP 정리 (Consistency Availability, Partition Tolerance theorem)
- 분산 시스템을 설계할 때 잘 이해해야 한다.
- 데이터 일관성, 가용성, 파티션 감내라는 3가지 요구사항을 동시에 만족하는 분산 시스템을 설계할 수는 없다.
- 각 요구사항의 의미는 다음과 같다.
  - `데이터 일관성`: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
  - `가용성`: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있어야 한다.
  - `파티션 감내`: 파티션은 두 노드 사이에 통신 장애가 발생했음을 의미한다. 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야 한다.
 
<br/>

🔽 CAP 정리

<img width="350" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/55437339/36283d39-4ea3-4c6e-ad24-e9920875daa9">

- 어떤 2가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다.
- `CP 시스템`: 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성을 희생한다.
- `AP 시스템`: 가용성과 파티션 감내를 지원하는 키-값 저장소. 데이터 일관성을 희생한다.
- `CA 시스템`: 일관성과 가용성을 지원하는 키-값 저장소. 파티션 감내는 지원하지 않는다.
- 통상 네트워크 장애는 피할 수 없으므로, 분산 시스템은 파티션 문제를 반드시 감내할 수 있어야 한다. (실세계에 CA 시스템 존재X)

<br/>

> ***이상적 상태***

분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다.

<br/>

🔽 3대의 복제(replica) 노드 n1, n2, n3에 데이터를 보관하는 상황

